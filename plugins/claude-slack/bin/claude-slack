#!/usr/bin/env node
'use strict';

/**
 * claude-slack â€” Claude Code ã®æ‰¿èªãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ»è³ªå•ãƒ»é€šçŸ¥ã‚’ Slack ãƒãƒ£ãƒ³ãƒãƒ«çµŒç”±ã§å‡¦ç†ã™ã‚‹ CLI ãƒ„ãƒ¼ãƒ«
 *
 * ä¸»ãªæ©Ÿèƒ½:
 *   - PermissionRequest ãƒ•ãƒƒã‚¯: ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œã®æ‰¿èª/æ‹’å¦ã‚’ Slack ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¾ãŸã¯ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡ã§å—ã‘å–ã‚‹
 *   - AskUserQuestion ãƒ•ãƒƒã‚¯: Claude ã‹ã‚‰ã®è³ªå•ã‚’ Slack ã«è»¢é€ã—ã€ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡ã§å›ç­”ã‚’å—ã‘å–ã‚‹
 *   - Notification ãƒ•ãƒƒã‚¯: Claude ã®å›ç­”ã‚’ Slack ã«é€šçŸ¥ã™ã‚‹
 *   - CLI ã‚³ãƒãƒ³ãƒ‰: enable/disable/config/test/status ã§ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¨ç®¡ç†ã‚’è¡Œã†
 *
 * è¨­å®šã®å„ªå…ˆåº¦ï¼ˆé«˜ã„é †ï¼‰: ç’°å¢ƒå¤‰æ•° > ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ­ãƒ¼ã‚«ãƒ« (.claude/claude-slack.local.md) > ã‚°ãƒ­ãƒ¼ãƒãƒ« (~/.claude-slack/config.json)
 */

const https = require('https');
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// --- ãƒ‘ã‚¹å®šç¾© ---
// ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šãƒ»çŠ¶æ…‹ãƒ»ãƒ­ã‚°ãƒ»ãƒ­ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’ ~/.claude-slack/ é…ä¸‹ã«é›†ç´„
const CONFIG_DIR = path.join(process.env.HOME, '.claude-slack');
const CONFIG_FILE = path.join(CONFIG_DIR, 'config.json');   // Slack ãƒˆãƒ¼ã‚¯ãƒ³ã‚„ãƒãƒ£ãƒ³ãƒãƒ« ID ã‚’ä¿æŒ
const STATE_FILE = path.join(CONFIG_DIR, 'state.json');      // æœ‰åŠ¹/ç„¡åŠ¹ã®çŠ¶æ…‹ã‚’ä¿æŒ
const LOG_FILE = path.join(CONFIG_DIR, 'debug.log');         // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã®å‡ºåŠ›å…ˆ
const LOG_MAX_SIZE = 1024 * 1024; // ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€å¤§ã‚µã‚¤ã‚º (1MB)
const LOCK_FILE = path.join(CONFIG_DIR, 'hook.lock');        // åŒæ™‚å®Ÿè¡Œé˜²æ­¢ç”¨ãƒ­ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ã®æ¥é ­è¾

// --- ã‚·ã‚°ãƒŠãƒ«ãƒãƒ³ãƒ‰ãƒ© ---
// Claude Code ãŒã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§å¿œç­”ã‚’å—ã‘ã‚‹ã¨ãƒ•ãƒƒã‚¯ãƒ—ãƒ­ã‚»ã‚¹ã« SIGTERM/SIGINT ã‚’é€ã‚‹ã€‚
// ãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†å‰ã«ãƒ­ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã—ã¦ã€æ¬¡å›ã®å®Ÿè¡ŒãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚
for (const sig of ['SIGTERM', 'SIGINT', 'SIGHUP']) {
  process.on(sig, () => {
    try { fs.unlinkSync(LOCK_FILE + '.permission'); } catch {}
    try { fs.unlinkSync(LOCK_FILE + '.question'); } catch {}
    process.exit(0);
  });
}

// --- ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çµµæ–‡å­—ã®å®šç¾© ---
// Slack ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¸ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§æ‰¿èª/æ‹’å¦ã‚’åˆ¤å®šã™ã‚‹ãŸã‚ã®çµµæ–‡å­—ã‚»ãƒƒãƒˆ
const APPROVE_REACTIONS = new Set([
  'white_check_mark', 'heavy_check_mark', 'thumbsup', '+1'  // âœ…ğŸ‘ = æ‰¿èª
]);
const DENY_REACTIONS = new Set([
  'x', 'no_entry', 'thumbsdown', '-1'                        // âŒğŸ‘ = æ‹’å¦
]);

// --- ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚° ---

/**
 * ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ãŒæœ€å¤§ã‚µã‚¤ã‚ºã‚’è¶…ãˆãŸå ´åˆã€å¾ŒåŠéƒ¨åˆ†ã®ã¿æ®‹ã—ã¦åˆ‡ã‚Šè©°ã‚ã‚‹ã€‚
 * ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ã‚’èª­ã¿è¾¼ã‚“ã§åŠåˆ†ã«ã‚«ãƒƒãƒˆã™ã‚‹ç°¡æ˜“ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–¹å¼ã€‚
 */
function rotateLogIfNeeded() {
  try {
    const stat = fs.statSync(LOG_FILE);
    if (stat.size > LOG_MAX_SIZE) {
      const content = fs.readFileSync(LOG_FILE, 'utf8');
      // å¾ŒåŠéƒ¨åˆ†ã‚’å–ã‚Šå‡ºã—ã€è¡Œã®é€”ä¸­ã§åˆ‡ã‚Œãªã„ã‚ˆã†æœ€åˆã®æ”¹è¡Œä»¥é™ã‚’æ®‹ã™
      const half = content.slice(content.length >> 1);
      const firstNewline = half.indexOf('\n');
      fs.writeFileSync(LOG_FILE, firstNewline >= 0 ? half.slice(firstNewline + 1) : half);
    }
  } catch { /* ignore */ }
}

// ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯ãƒ—ãƒ­ã‚»ã‚¹ã”ã¨ã«1å›ã ã‘å®Ÿè¡Œ
let _logRotated = false;

/**
 * ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ãã§ãƒ‡ãƒãƒƒã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½è¨˜ã™ã‚‹ã€‚
 * æœ€åˆã®å‘¼ã³å‡ºã—æ™‚ã«ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
 */
function debugLog(msg) {
  try {
    if (!_logRotated) {
      _logRotated = true;
      rotateLogIfNeeded();
    }
    const ts = new Date().toISOString();
    fs.appendFileSync(LOG_FILE, `[${ts}] ${msg}\n`);
  } catch { /* ignore */ }
}

// --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---

/**
 * ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰è¦ªã‚’è¾¿ã‚Šã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ­ãƒ¼ã‚«ãƒ«è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã™ã€‚
 * .claude/claude-slack.local.md ãŒè¦‹ã¤ã‹ã‚Œã°ãã®ãƒ‘ã‚¹ã‚’è¿”ã™ã€‚
 * ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ«ãƒ¼ãƒˆã¾ã§è¾¿ã£ã¦ã‚‚è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã° null ã‚’è¿”ã™ã€‚
 */
function findProjectLocalConfig() {
  let dir = process.cwd();
  const root = path.parse(dir).root;
  while (true) {
    const candidate = path.join(dir, '.claude', 'claude-slack.local.md');
    if (fs.existsSync(candidate)) return candidate;
    const parent = path.dirname(dir);
    if (parent === dir || parent === root) break;
    dir = parent;
  }
  return null;
}

/**
 * Markdown ãƒ•ã‚¡ã‚¤ãƒ«ã® YAML ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ï¼ˆ--- ã§å›²ã¾ã‚ŒãŸéƒ¨åˆ†ï¼‰ã‚’ç°¡æ˜“ãƒ‘ãƒ¼ã‚¹ã™ã‚‹ã€‚
 * ã‚­ãƒ¼: å€¤ ã®å½¢å¼ã‚’èª­ã¿å–ã‚Šã€æ–‡å­—åˆ—ã®å¼•ç”¨ç¬¦é™¤å»ãƒ»boolean/number å¤‰æ›ã‚’è¡Œã†ã€‚
 * æ³¨æ„: å€¤ã«ã‚³ãƒ­ãƒ³ã‚’å«ã‚€å ´åˆï¼ˆä¾‹: URLï¼‰ã¯æ­£ã—ããƒ‘ãƒ¼ã‚¹ã§ããªã„å ´åˆãŒã‚ã‚‹ã€‚
 */
function parseYamlFrontmatter(content) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return {};
  const result = {};
  for (const line of match[1].split('\n')) {
    const kv = line.match(/^(\w+)\s*:\s*(.+)$/);
    if (kv) {
      let val = kv[2].trim();
      // å¼•ç”¨ç¬¦ã§å›²ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯é™¤å»
      if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
        val = val.slice(1, -1);
      }
      // å‹å¤‰æ›: boolean ã¨æ•´æ•°
      if (val === 'true') val = true;
      else if (val === 'false') val = false;
      else if (/^\d+$/.test(val)) val = parseInt(val, 10);
      result[kv[1]] = val;
    }
  }
  return result;
}

/**
 * 3å±¤ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¨­å®šã‚’èª­ã¿è¾¼ã‚€ã€‚
 * å„ªå…ˆåº¦: ç’°å¢ƒå¤‰æ•° > ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ­ãƒ¼ã‚«ãƒ« > ã‚°ãƒ­ãƒ¼ãƒãƒ«
 * _source ã«å„è¨­å®šå€¤ãŒã©ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”±æ¥ã‹ã‚’è¨˜éŒ²ã™ã‚‹ï¼ˆstatus ã‚³ãƒãƒ³ãƒ‰ã§è¡¨ç¤ºç”¨ï¼‰ã€‚
 * ãƒˆãƒ¼ã‚¯ãƒ³ã‚‚ãƒãƒ£ãƒ³ãƒãƒ«ã‚‚æœªè¨­å®šã®å ´åˆã¯ null ã‚’è¿”ã™ã€‚
 */
function loadConfig() {
  // ãƒ¬ã‚¤ãƒ¤ãƒ¼1: ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šï¼ˆæœ€ä½å„ªå…ˆåº¦ï¼‰
  let config = { _source: {} };
  try {
    const global = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));
    if (global.slack_bot_token) { config.slack_bot_token = global.slack_bot_token; config._source.slack_bot_token = 'global'; }
    if (global.channel_id) { config.channel_id = global.channel_id; config._source.channel_id = 'global'; }
    if (global.timeout) { config.timeout = global.timeout; config._source.timeout = 'global'; }
    if (global.anthropic_api_key) { config.anthropic_api_key = global.anthropic_api_key; config._source.anthropic_api_key = 'global'; }
  } catch { /* ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç„¡è¦– */ }

  // ãƒ¬ã‚¤ãƒ¤ãƒ¼2: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ­ãƒ¼ã‚«ãƒ«è¨­å®šï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚’ä¸Šæ›¸ãï¼‰
  const localPath = findProjectLocalConfig();
  if (localPath) {
    try {
      const content = fs.readFileSync(localPath, 'utf8');
      const local = parseYamlFrontmatter(content);
      if (local.slack_bot_token) { config.slack_bot_token = local.slack_bot_token; config._source.slack_bot_token = 'local'; }
      if (local.channel_id) { config.channel_id = local.channel_id; config._source.channel_id = 'local'; }
      if (local.timeout !== undefined) { config.timeout = local.timeout; config._source.timeout = 'local'; }
      if (local.anthropic_api_key) { config.anthropic_api_key = local.anthropic_api_key; config._source.anthropic_api_key = 'local'; }
      if (local.enabled !== undefined) { config._localEnabled = local.enabled; }
      config._localPath = localPath;
    } catch { /* ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦– */ }
  }

  // ãƒ¬ã‚¤ãƒ¤ãƒ¼3: ç’°å¢ƒå¤‰æ•°ï¼ˆæœ€é«˜å„ªå…ˆåº¦ï¼‰
  if (process.env.CLAUDE_SLACK_TOKEN) { config.slack_bot_token = process.env.CLAUDE_SLACK_TOKEN; config._source.slack_bot_token = 'env'; }
  if (process.env.CLAUDE_SLACK_CHANNEL) { config.channel_id = process.env.CLAUDE_SLACK_CHANNEL; config._source.channel_id = 'env'; }
  if (process.env.CLAUDE_SLACK_TIMEOUT) { config.timeout = parseInt(process.env.CLAUDE_SLACK_TIMEOUT, 10); config._source.timeout = 'env'; }
  if (process.env.ANTHROPIC_API_KEY) { config.anthropic_api_key = process.env.ANTHROPIC_API_KEY; config._source.anthropic_api_key = 'env'; }

  // ãƒˆãƒ¼ã‚¯ãƒ³ã‚‚ãƒãƒ£ãƒ³ãƒãƒ«ã‚‚æœªè¨­å®šãªã‚‰è¨­å®šãªã—ã¨ã¿ãªã™
  if (!config.slack_bot_token && !config.channel_id) return null;
  return config;
}

/** ã‚°ãƒ­ãƒ¼ãƒãƒ«ã®æœ‰åŠ¹/ç„¡åŠ¹çŠ¶æ…‹ã‚’èª­ã¿è¾¼ã‚€ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã‘ã‚Œã°ç„¡åŠ¹ã¨ã—ã¦æ‰±ã†ã€‚ */
function loadState() {
  try {
    return JSON.parse(fs.readFileSync(STATE_FILE, 'utf8'));
  } catch {
    return { enabled: false };
  }
}

/**
 * claude-slack ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ã€‚
 * å„ªå…ˆåº¦: ç’°å¢ƒå¤‰æ•° CLAUDE_SLACK_ENABLED > ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ­ãƒ¼ã‚«ãƒ« > ã‚°ãƒ­ãƒ¼ãƒãƒ« state.json
 */
function isEnabled() {
  // ç’°å¢ƒå¤‰æ•°ãŒæœ€å„ªå…ˆ
  if (process.env.CLAUDE_SLACK_ENABLED !== undefined) {
    return process.env.CLAUDE_SLACK_ENABLED === 'true' || process.env.CLAUDE_SLACK_ENABLED === '1';
  }
  // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ­ãƒ¼ã‚«ãƒ«ã®è¨­å®šãŒã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å„ªå…ˆ
  const config = loadConfig();
  if (config?._localEnabled !== undefined) return config._localEnabled;
  // æœ€å¾Œã«ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
  const state = loadState();
  return state.enabled;
}

/**
 * ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ­ãƒ¼ã‚«ãƒ«è¨­å®šã‚’ .claude/claude-slack.local.md ã« YAML ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼å½¢å¼ã§ä¿å­˜ã™ã‚‹ã€‚
 * ãƒˆãƒ¼ã‚¯ãƒ³ç­‰ã®æ©Ÿå¯†æƒ…å ±ã‚’å«ã‚€ãŸã‚ã€ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ã‚’ 600 ã«è¨­å®šã™ã‚‹ã€‚
 */
function saveLocalConfig(config) {
  const dir = path.join(process.cwd(), '.claude');
  fs.mkdirSync(dir, { recursive: true });
  const filePath = path.join(dir, 'claude-slack.local.md');

  const lines = ['---'];
  if (config.slack_bot_token) lines.push(`slack_bot_token: ${config.slack_bot_token}`);
  if (config.channel_id) lines.push(`channel_id: ${config.channel_id}`);
  if (config.timeout) lines.push(`timeout: ${config.timeout}`);
  if (config.anthropic_api_key) lines.push(`anthropic_api_key: ${config.anthropic_api_key}`);
  if (config.enabled !== undefined) lines.push(`enabled: ${config.enabled}`);
  lines.push('---');
  lines.push('');

  fs.writeFileSync(filePath, lines.join('\n'));
  fs.chmodSync(filePath, 0o600);
}

/** ã‚°ãƒ­ãƒ¼ãƒãƒ«ã®æœ‰åŠ¹/ç„¡åŠ¹çŠ¶æ…‹ã‚’ state.json ã«ä¿å­˜ã™ã‚‹ã€‚ */
function saveState(state) {
  fs.mkdirSync(CONFIG_DIR, { recursive: true });
  fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2) + '\n');
}

/** ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã‚’ config.json ã«ä¿å­˜ã™ã‚‹ã€‚æ©Ÿå¯†æƒ…å ±ã‚’å«ã‚€ãŸã‚ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ 600 ã«è¨­å®šã€‚ */
function saveConfig(config) {
  fs.mkdirSync(CONFIG_DIR, { recursive: true });
  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2) + '\n');
  fs.chmodSync(CONFIG_FILE, 0o600);
}

/** æ¨™æº–å…¥åŠ›ã‚’æœ€å¾Œã¾ã§èª­ã¿å–ã£ã¦æ–‡å­—åˆ—ã¨ã—ã¦è¿”ã™ã€‚ãƒ•ãƒƒã‚¯ã®å…¥åŠ› JSON ã‚’å—ã‘å–ã‚‹ãŸã‚ã«ä½¿ç”¨ã€‚ */
function readStdin() {
  return new Promise((resolve) => {
    let data = '';
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', (chunk) => { data += chunk; });
    process.stdin.on('end', () => resolve(data));
    process.stdin.on('error', () => resolve(data));
  });
}

/** æŒ‡å®šãƒŸãƒªç§’ã ã‘å¾…æ©Ÿã™ã‚‹ Promise ã‚’è¿”ã™ã€‚ãƒãƒ¼ãƒªãƒ³ã‚°é–“éš”ã®åˆ¶å¾¡ã«ä½¿ç”¨ã€‚ */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// --- å…¥åŠ›ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ ---

/**
 * PermissionRequest ãƒ•ãƒƒã‚¯ã®å…¥åŠ›ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã‚’æ¤œè¨¼ã™ã‚‹ã€‚
 * tool_name ãŒæ–‡å­—åˆ—ã§å­˜åœ¨ã—ã€ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã„ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã€‚
 */
function isValidPermissionRequest(input) {
  if (!input || typeof input.tool_name !== 'string' || !input.tool_name) return false;
  if (input.type === 'error' || input.error) return false;
  if (input.tool_input && typeof input.tool_input !== 'object') return false;
  if (input.tool_input?.type === 'error' || input.tool_input?.error) return false;
  return true;
}

/**
 * AskUserQuestion ãƒ•ãƒƒã‚¯ã®å…¥åŠ›ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã‚’æ¤œè¨¼ã™ã‚‹ã€‚
 * questions é…åˆ—ãŒå­˜åœ¨ã—ã€å„è¦ç´ ã« question æ–‡å­—åˆ—ãŒã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã€‚
 */
function isValidAskUserQuestion(input) {
  if (!input || input.type === 'error' || input.error) return false;
  const toolInput = input.tool_input || {};
  if (!Array.isArray(toolInput.questions) || toolInput.questions.length === 0) return false;
  return toolInput.questions.every(q => typeof q.question === 'string');
}

/**
 * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒ API ã‚¨ãƒ©ãƒ¼ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ã€‚
 * ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ Slack ã«é€šçŸ¥ã—ãªã„ã‚ˆã†ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã€‚
 */
function isErrorMessage(message) {
  if (!message || typeof message !== 'string') return false;
  const errorPatterns = [
    /API Error:/i,
    /invalid_request_error/i,
    /tool_use ids must be unique/i,
    /internal_server_error/i,
    /"type"\s*:\s*"error"/,
    /rate_limit_error/i,
  ];
  return errorPatterns.some(p => p.test(message));
}

// --- æ’ä»–åˆ¶å¾¡ï¼ˆãƒ­ãƒƒã‚¯ï¼‰ ---

/**
 * åå‰ä»˜ããƒ­ãƒƒã‚¯ã‚’å–å¾—ã™ã‚‹ã€‚åŒã˜ç¨®é¡ã®ãƒ•ãƒƒã‚¯ï¼ˆpermission/questionï¼‰ãŒåŒæ™‚ã«å‹•ã‹ãªã„ã‚ˆã†åˆ¶å¾¡ã€‚
 *
 * å‹•ä½œ:
 *   1. æ—¢å­˜ã®ãƒ­ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹å ´åˆã€çµŒéæ™‚é–“ã‚’ç¢ºèª
 *   2. maxAgeMs ä»¥å†…ãªã‚‰å‰ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ SIGTERM ã§åœæ­¢ã—ã¦å¼•ãç¶™ã
 *   3. ãƒ­ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ’ä»–ãƒ¢ãƒ¼ãƒ‰ ('wx') ã§ä½œæˆã—ã€è‡ªåˆ†ã® PID ã‚’æ›¸ãè¾¼ã‚€
 *
 * æ³¨æ„: existsSync â†’ unlinkSync â†’ writeFileSync ã®é–“ã«ã‚ãšã‹ãªãƒ¬ãƒ¼ã‚¹ã‚³ãƒ³ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã®å¯èƒ½æ€§ãŒã‚ã‚‹ãŒã€
 *       åŒä¸€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§ã®ä½¿ç”¨ã‚’å‰æã¨ã—ã¦ã„ã‚‹ãŸã‚å®Ÿç”¨ä¸Šå•é¡Œãªã„ã€‚
 *
 * @param {string} lockName - ãƒ­ãƒƒã‚¯åï¼ˆ'permission' ã¾ãŸã¯ 'question'ï¼‰
 * @param {number} maxAgeMs - ãƒ­ãƒƒã‚¯ã®æœ€å¤§æœ‰åŠ¹æœŸé–“ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 2åˆ†ï¼‰
 * @returns {boolean} ãƒ­ãƒƒã‚¯å–å¾—ã«æˆåŠŸã—ãŸã‚‰ true
 */
function acquireLock(lockName, maxAgeMs = 120000) {
  const lockPath = LOCK_FILE + '.' + lockName;
  try {
    if (fs.existsSync(lockPath)) {
      const stat = fs.statSync(lockPath);
      const ageMs = Date.now() - stat.mtimeMs;
      if (ageMs < maxAgeMs) {
        // å‰ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒæ®‹ã£ã¦ã„ã‚Œã°çµ‚äº†ã•ã›ã¦å¼•ãç¶™ã
        try {
          const oldPid = parseInt(fs.readFileSync(lockPath, 'utf8').trim(), 10);
          if (oldPid && oldPid !== process.pid) {
            process.kill(oldPid, 'SIGTERM');
            debugLog(`acquireLock: killed stale process ${oldPid} for ${lockName}`);
          }
        } catch { /* ãƒ—ãƒ­ã‚»ã‚¹ãŒæ—¢ã«çµ‚äº†ã—ã¦ã„ã‚‹å ´åˆã¯ç„¡è¦– */ }
      }
      fs.unlinkSync(lockPath);
    }
    // æ’ä»–ãƒ¢ãƒ¼ãƒ‰ã§ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆï¼ˆæ—¢ã«ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Œã°å¤±æ•—ã™ã‚‹ï¼‰
    fs.writeFileSync(lockPath, String(process.pid), { flag: 'wx' });
    return true;
  } catch {
    return false;
  }
}

/** ãƒ­ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã—ã¦ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã™ã‚‹ã€‚ */
function releaseLock(lockName) {
  const lockPath = LOCK_FILE + '.' + lockName;
  try { fs.unlinkSync(lockPath); } catch { /* ignore */ }
}

/** æ–‡å­—åˆ—ã‚’æœ€å¤§é•·ã§åˆ‡ã‚Šè©°ã‚ã‚‹ã€‚Slack ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ–‡å­—æ•°åˆ¶é™ã«å¯¾å¿œã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã€‚ */
function truncate(str, max) {
  if (!str) return '';
  return str.length > max ? str.slice(0, max - 3) + '...' : str;
}

/**
 * Slack ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ä»˜ä¸ã™ã‚‹ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ï¼ˆGit ãƒ–ãƒ©ãƒ³ãƒåãƒ»ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåï¼‰ã‚’å–å¾—ã™ã‚‹ã€‚
 * Git ãƒªãƒã‚¸ãƒˆãƒªã§ãªã„å ´åˆã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã®ã¿è¿”ã™ã€‚
 */
function getProjectContext() {
  const parts = [];
  try {
    const branch = execSync('git rev-parse --abbrev-ref HEAD', { timeout: 2000, stdio: ['ignore', 'pipe', 'ignore'] }).toString().trim();
    if (branch) parts.push(`Branch: \`${branch}\``);
  } catch { /* Git ãƒªãƒã‚¸ãƒˆãƒªã§ãªã„å ´åˆã¯ç„¡è¦– */ }
  parts.push(`Project: \`${path.basename(process.cwd())}\``);
  return parts;
}

/**
 * ãƒˆãƒ©ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆJSONL å½¢å¼ï¼‰ã‹ã‚‰ç›´è¿‘ã®ä¼šè©±å±¥æ­´ã‚’æŠ½å‡ºã™ã‚‹ã€‚
 * AI ã‚µãƒãƒªãƒ¼ç”Ÿæˆã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦ä½¿ç”¨ã€‚
 * æœ€æ–° maxLines è¡Œã‚’èª­ã¿å–ã‚Šã€Assistant/User/Tool ã®è¦ç´„ã‚’æœ€å¤§10ä»¶è¿”ã™ã€‚
 */
function getRecentTranscript(transcriptPath, maxLines = 30) {
  try {
    if (!transcriptPath) return '';
    const content = fs.readFileSync(transcriptPath, 'utf8');
    const lines = content.trim().split('\n').slice(-maxLines);
    const parts = [];
    for (const line of lines) {
      try {
        const entry = JSON.parse(line);
        if (entry.type === 'assistant' && Array.isArray(entry.message?.content)) {
          for (const block of entry.message.content) {
            if (block.type === 'text' && block.text) {
              parts.push(`[Assistant] ${block.text.slice(0, 200)}`);
            } else if (block.type === 'tool_use') {
              const inp = JSON.stringify(block.input || {}).slice(0, 150);
              parts.push(`[Tool] ${block.name}: ${inp}`);
            }
          }
        } else if (entry.type === 'human' && Array.isArray(entry.message?.content)) {
          for (const block of entry.message.content) {
            if (block.type === 'text' && block.text) {
              parts.push(`[User] ${block.text.slice(0, 200)}`);
            }
          }
        }
      } catch { /* ãƒ‘ãƒ¼ã‚¹ã§ããªã„è¡Œã¯ã‚¹ã‚­ãƒƒãƒ— */ }
    }
    return parts.slice(-10).join('\n');
  } catch (e) {
    debugLog(`getRecentTranscript: error: ${e.message}`);
    return '';
  }
}

/**
 * Anthropic Messages API ã‚’å‘¼ã³å‡ºã—ã¦çŸ­ã„ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’å¾—ã‚‹ã€‚
 * ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œã® AI ã‚µãƒãƒªãƒ¼ç”Ÿæˆã«ä½¿ç”¨ã€‚Haiku ãƒ¢ãƒ‡ãƒ«ã§é«˜é€Ÿãƒ»ä½ã‚³ã‚¹ãƒˆã«å‡¦ç†ã™ã‚‹ã€‚
 * ã‚¨ãƒ©ãƒ¼æ™‚ã¯ç©ºæ–‡å­—åˆ—ã‚’è¿”ã™ï¼ˆã‚µãƒãƒªãƒ¼ã¯ä»»æ„æ©Ÿèƒ½ã®ãŸã‚ã€å¤±æ•—ã—ã¦ã‚‚å‡¦ç†ã‚’æ­¢ã‚ãªã„ï¼‰ã€‚
 */
function callAnthropic(apiKey, prompt, timeoutMs = 5000) {
  return new Promise((resolve) => {
    const body = JSON.stringify({
      model: 'claude-haiku-4-5-20251001',
      max_tokens: 200,
      messages: [{ role: 'user', content: prompt }]
    });
    const req = https.request({
      hostname: 'api.anthropic.com',
      path: '/v1/messages',
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01',
        'Content-Length': Buffer.byteLength(body),
      },
    }, (res) => {
      res.setEncoding('utf8');
      let data = '';
      res.on('data', (chunk) => { data += chunk; });
      res.on('end', () => {
        try {
          const parsed = JSON.parse(data);
          const text = parsed.content?.[0]?.text || '';
          resolve(text);
        } catch { resolve(''); }
      });
    });
    req.on('error', () => resolve(''));
    req.setTimeout(timeoutMs, () => { req.destroy(); resolve(''); });
    req.write(body);
    req.end();
  });
}

/**
 * ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œã®å†…å®¹ã‚’æ—¥æœ¬èª1æ–‡ã§è¦ç´„ã™ã‚‹ï¼ˆAI ã‚µãƒãƒªãƒ¼ï¼‰ã€‚
 * anthropic_api_key ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿å‹•ä½œã™ã‚‹ä»»æ„æ©Ÿèƒ½ã€‚
 * ãƒˆãƒ©ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‹ã‚‰ç›´è¿‘ã®ä¼šè©±ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—ã—ã€ã€ŒClaude ãŒä½•ã‚’ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã‹ã€ã‚’è¦ç´„ã€‚
 */
async function generateSummary(config, toolName, toolInput, transcriptPath) {
  if (!config.anthropic_api_key) return '';
  const context = getRecentTranscript(transcriptPath);
  const toolDesc = toolInput.description ? `\nDescription: ${toolInput.description}` : '';
  const inputSummary = JSON.stringify(toolInput, null, 2).slice(0, 1000);

  const prompt = `You are summarizing a Claude Code operation for a human reviewer on Slack.
Reply in Japanese, one sentence only, max 100 characters. No markdown.

Tool: ${toolName}${toolDesc}
Input: ${inputSummary}
${context ? `\nRecent conversation:\n${context}` : ''}

What is Claude trying to do and why? Reply in one concise sentence in Japanese.`;

  debugLog('generateSummary: calling Anthropic API');
  const summary = await callAnthropic(config.anthropic_api_key, prompt);
  debugLog(`generateSummary: result="${summary.slice(0, 100)}"`);
  return summary.trim();
}

// --- Slack API ãƒ©ãƒƒãƒ‘ãƒ¼ ---

/**
 * Slack Web API ã‚’1å›å‘¼ã³å‡ºã™ã€‚GET/POST ã«å¯¾å¿œã€‚
 * ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ (429) ã®å ´åˆã¯ _rateLimited ãƒ•ãƒ©ã‚°ä»˜ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã€‚
 */
function slackRequestOnce(method, token, params, httpMethod = 'POST') {
  return new Promise((resolve, reject) => {
    let reqOptions;
    let body = null;

    if (httpMethod === 'GET') {
      const qs = new URLSearchParams(params).toString();
      reqOptions = {
        hostname: 'slack.com',
        path: `/api/${method}?${qs}`,
        method: 'GET',
        headers: { 'Authorization': `Bearer ${token}` },
      };
    } else {
      body = JSON.stringify(params);
      reqOptions = {
        hostname: 'slack.com',
        path: `/api/${method}`,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Authorization': `Bearer ${token}`,
          'Content-Length': Buffer.byteLength(body),
        },
      };
    }

    const req = https.request(reqOptions, (res) => {
      let responseData = '';
      res.on('data', (chunk) => { responseData += chunk; });
      res.on('end', () => {
        try {
          const parsed = JSON.parse(responseData);
          if (res.statusCode === 429) {
            const retryAfter = parseInt(res.headers['retry-after'] || '10', 10);
            resolve({ _rateLimited: true, retryAfter });
          } else {
            resolve(parsed);
          }
        } catch (e) {
          reject(new Error(`Failed to parse Slack response: ${e.message}`));
        }
      });
    });
    req.on('error', reject);
    if (body) req.write(body);
    req.end();
  });
}

/**
 * Slack API ã‚’ãƒªãƒˆãƒ©ã‚¤ä»˜ãã§å‘¼ã³å‡ºã™ã€‚
 * ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆã«é­é‡ã—ãŸå ´åˆã€Retry-After ãƒ˜ãƒƒãƒ€ãƒ¼ã®ç§’æ•°ã ã‘å¾…ã£ã¦æœ€å¤§3å›ãƒªãƒˆãƒ©ã‚¤ã™ã‚‹ã€‚
 */
async function slackRequest(method, token, params, httpMethod = 'POST') {
  for (let attempt = 0; attempt < 3; attempt++) {
    const result = await slackRequestOnce(method, token, params, httpMethod);
    if (result._rateLimited) {
      await sleep(result.retryAfter * 1000);
      continue;
    }
    return result;
  }
  throw new Error(`Slack API rate limited after 3 retries`);
}

/** Slack ãƒãƒ£ãƒ³ãƒãƒ«ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿ã™ã‚‹ã€‚blocks ã‚’æŒ‡å®šã™ã‚‹ã¨ãƒªãƒƒãƒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ãªã‚‹ã€‚ */
async function postMessage(token, channel, text, blocks) {
  const payload = { channel, text };
  if (blocks) payload.blocks = blocks;
  const result = await slackRequest('chat.postMessage', token, payload);
  if (!result.ok) throw new Error(`Slack postMessage error: ${result.error}`);
  return result;
}

/** æŒ‡å®šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ (ts) ã®ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡ã‚’å–å¾—ã™ã‚‹ã€‚æœ€æ–°10ä»¶ã¾ã§ã€‚ */
async function getThreadReplies(token, channel, ts) {
  const result = await slackRequest('conversations.replies', token, {
    channel, ts, limit: '10'
  }, 'GET');
  if (!result.ok) throw new Error(`Slack conversations.replies error: ${result.error}`);
  return result.messages || [];
}

/** æŒ‡å®šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ (ts) ã«ä»˜ã‘ã‚‰ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ä¸€è¦§ã‚’å–å¾—ã™ã‚‹ã€‚ */
async function getReactions(token, channel, ts) {
  const result = await slackRequest('reactions.get', token, {
    channel, timestamp: ts, full: 'true'
  }, 'GET');
  if (!result.ok) {
    debugLog(`getReactions: error: ${result.error}`);
    return [];
  }
  return (result.message && result.message.reactions) || [];
}

/**
 * Slack ã®ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡ã‚’ãƒãƒ¼ãƒªãƒ³ã‚°ã—ã¦ã€äººé–“ã®è¿”ä¿¡ãƒ†ã‚­ã‚¹ãƒˆã‚’å¾…ã¤ã€‚
 * AskUserQuestion ãƒ•ãƒƒã‚¯ç”¨ã€‚
 *
 * ãƒãƒ¼ãƒªãƒ³ã‚°é–“éš”: æœ€åˆã®1åˆ†ã¯5ç§’ã€ãã®å¾Œã¯10ç§’ã«ç·©å’Œã™ã‚‹ã€‚
 * ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã™ã‚‹ã¨ null ã‚’è¿”ã—ã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã‚‹ã€‚
 */
async function pollForReply(token, channel, ts, timeoutMs = 300000) {
  const startTime = Date.now();
  let interval = 5000;
  let pollCount = 0;

  debugLog(`pollForReply: start polling ts=${ts} timeout=${timeoutMs}ms`);

  while (Date.now() - startTime < timeoutMs) {
    await sleep(interval);
    pollCount++;

    try {
      const messages = await getThreadReplies(token, channel, ts);
      // ãƒœãƒƒãƒˆã®è¿”ä¿¡ã‚’é™¤å¤–ã—ã€äººé–“ã®è¿”ä¿¡ã®ã¿ã‚’å–å¾—
      const replies = messages.filter(m => m.ts !== ts && !m.bot_id);
      debugLog(`pollForReply: poll #${pollCount} - ${messages.length} messages, ${replies.length} human replies`);
      if (replies.length > 0) {
        // æœ€æ–°ã®è¿”ä¿¡ã‚’ä½¿ç”¨
        const replyText = replies[replies.length - 1].text;
        debugLog(`pollForReply: got reply: "${replyText}"`);
        return replyText;
      }
    } catch (e) {
      debugLog(`pollForReply: poll #${pollCount} error: ${e.message}`);
    }

    // 1åˆ†çµŒéå¾Œã¯ãƒãƒ¼ãƒªãƒ³ã‚°é–“éš”ã‚’åºƒã’ã¦ API è² è·ã‚’è»½æ¸›
    if (Date.now() - startTime > 60000 && interval < 10000) {
      interval = 10000;
    }
  }

  debugLog(`pollForReply: timed out after ${pollCount} polls`);
  return null;
}

/**
 * Slack ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¨ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡ã‚’ãƒãƒ¼ãƒªãƒ³ã‚°ã—ã¦ã€æ‰¿èª/æ‹’å¦ã®åˆ¤æ–­ã‚’å¾…ã¤ã€‚
 * PermissionRequest ãƒ•ãƒƒã‚¯ç”¨ã€‚
 *
 * åˆ¤å®šæ–¹æ³•:
 *   - ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³: âœ…/ğŸ‘ = æ‰¿èªã€âŒ/ğŸ‘ = æ‹’å¦ï¼ˆæ¯å›ãƒã‚§ãƒƒã‚¯ï¼‰
 *   - ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡: "approve/allow/yes/y/ok" ã§å§‹ã¾ã‚Œã°æ‰¿èªã€ãã‚Œä»¥å¤–ã¯æ‹’å¦ï¼ˆ3å›ã«1å›ãƒã‚§ãƒƒã‚¯ï¼‰
 *
 * ãƒãƒ¼ãƒªãƒ³ã‚°é–“éš”: æœ€åˆã®1åˆ†ã¯5ç§’ã€ãã®å¾Œã¯10ç§’ã«ç·©å’Œã€‚
 * ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡ã®ãƒã‚§ãƒƒã‚¯é »åº¦ãŒä½ã„ã®ã¯ã€conversations.replies ãŒ Tier 1 ã®ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆã®ãŸã‚ã€‚
 * ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã™ã‚‹ã¨ null ã‚’è¿”ã™ã€‚
 */
async function pollForApproval(token, channel, ts, timeoutMs = 300000) {
  const startTime = Date.now();
  let interval = 5000;
  let pollCount = 0;

  debugLog(`pollForApproval: start polling ts=${ts} timeout=${timeoutMs}ms`);

  while (Date.now() - startTime < timeoutMs) {
    await sleep(interval);
    pollCount++;

    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ¯å›ãƒã‚§ãƒƒã‚¯ï¼ˆreactions.get ã¯ Tier 2+ ã§æ¯”è¼ƒçš„ä½™è£•ãŒã‚ã‚‹ï¼‰
    try {
      const reactions = await getReactions(token, channel, ts);
      for (const r of reactions) {
        if (APPROVE_REACTIONS.has(r.name)) {
          debugLog(`pollForApproval: approved via reaction :${r.name}: (count=${r.count})`);
          return { decision: 'allow', source: 'reaction', detail: r.name };
        }
        if (DENY_REACTIONS.has(r.name)) {
          debugLog(`pollForApproval: denied via reaction :${r.name}: (count=${r.count})`);
          return { decision: 'deny', source: 'reaction', detail: r.name };
        }
      }
    } catch (e) {
      debugLog(`pollForApproval: reaction check #${pollCount} error: ${e.message}`);
    }

    // ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡ã¯3å›ã«1å›ãƒã‚§ãƒƒã‚¯ï¼ˆconversations.replies ã¯ Tier 1 ã§ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆãŒå³ã—ã„ï¼‰
    if (pollCount % 3 === 0) {
      try {
        const messages = await getThreadReplies(token, channel, ts);
        const replies = messages.filter(m => m.ts !== ts && !m.bot_id);
        debugLog(`pollForApproval: thread check #${pollCount} - ${replies.length} human replies`);
        if (replies.length > 0) {
          const replyText = replies[replies.length - 1].text;
          const replyLower = replyText.toLowerCase().trim();
          // "approve", "allow", "yes", "y", "ok" ã§å§‹ã¾ã‚Œã°æ‰¿èªã€ãã‚Œä»¥å¤–ã¯æ‹’å¦
          const isApproved = /^(approve|allow|yes|y|ok)/.test(replyLower);
          const decision = isApproved ? 'allow' : 'deny';
          debugLog(`pollForApproval: ${decision} via thread reply: "${replyText}"`);
          return { decision, source: 'thread', detail: replyText };
        }
      } catch (e) {
        debugLog(`pollForApproval: thread check #${pollCount} error: ${e.message}`);
      }
    }

    // 1åˆ†çµŒéå¾Œã¯ãƒãƒ¼ãƒªãƒ³ã‚°é–“éš”ã‚’åºƒã’ã¦ API è² è·ã‚’è»½æ¸›
    if (Date.now() - startTime > 60000 && interval < 10000) {
      interval = 10000;
    }
  }

  debugLog(`pollForApproval: timed out after ${pollCount} polls`);
  return null;
}

// --- ãƒ•ãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ© ---

/**
 * PermissionRequest ãƒ•ãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ã€‚
 * Claude Code ãŒãƒ„ãƒ¼ãƒ«å®Ÿè¡Œã®æ‰¿èªã‚’æ±‚ã‚ã‚‹éš›ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚
 *
 * å‡¦ç†ãƒ•ãƒ­ãƒ¼:
 *   1. æœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯ãƒ»è¨­å®šèª­ã¿è¾¼ã¿ãƒ»æ¨™æº–å…¥åŠ›ãƒ‘ãƒ¼ã‚¹
 *   2. ãƒ­ãƒƒã‚¯å–å¾—ï¼ˆåŒæ™‚ã«è¤‡æ•°ã®æ‰¿èªãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒèµ°ã‚‰ãªã„ã‚ˆã†åˆ¶å¾¡ï¼‰
 *   3. ãƒ„ãƒ¼ãƒ«ç¨®åˆ¥ã«å¿œã˜ãŸè©³ç´°æƒ…å ±ã‚’æ§‹ç¯‰ï¼ˆBash/Write/Edit/ãã®ä»–ï¼‰
 *   4. AI ã‚µãƒãƒªãƒ¼ç”Ÿæˆï¼ˆä»»æ„ï¼‰
 *   5. Slack ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿
 *   6. ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¾ãŸã¯ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡ã‚’ãƒãƒ¼ãƒªãƒ³ã‚°ã—ã¦æ‰¿èª/æ‹’å¦ã‚’å–å¾—
 *   7. çµæœã‚’ JSON ã§æ¨™æº–å‡ºåŠ›ã«è¿”ã™
 */
async function hookPermissionRequest() {
  debugLog('hookPermissionRequest: start');
  if (!isEnabled()) { debugLog('hookPermissionRequest: disabled, exit'); process.exit(0); }

  const config = loadConfig();
  if (!config?.slack_bot_token || !config?.channel_id) { debugLog('hookPermissionRequest: no config, exit'); process.exit(0); }

  // æ¨™æº–å…¥åŠ›ã‹ã‚‰ Claude Code ãŒæ¸¡ã™ãƒ•ãƒƒã‚¯å…¥åŠ› JSON ã‚’èª­ã¿å–ã‚‹
  let input;
  try {
    const raw = await readStdin();
    debugLog(`hookPermissionRequest: stdin length=${raw.length}`);
    input = JSON.parse(raw);
  } catch (e) {
    debugLog(`hookPermissionRequest: stdin parse error: ${e.message}`);
    process.exit(0);
  }

  // å…¥åŠ›ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³: ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ä¸æ­£ãªå…¥åŠ›ã¯ç„¡è¦–
  if (!isValidPermissionRequest(input)) {
    debugLog(`hookPermissionRequest: REJECTED invalid input: ${JSON.stringify(input).slice(0, 200)}`);
    process.exit(0);
  }

  // æ’ä»–ãƒ­ãƒƒã‚¯: åˆ¥ã®æ‰¿èªãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒå‡¦ç†ä¸­ãªã‚‰ä½•ã‚‚ã›ãšçµ‚äº†
  if (!acquireLock('permission')) {
    debugLog('hookPermissionRequest: SKIPPED - another permission request is already active');
    process.exit(0);
  }

  const toolName = input.tool_name || 'unknown';
  const toolInput = input.tool_input || {};
  const sessionId = input.session_id || 'unknown';

  // ãƒ„ãƒ¼ãƒ«ç¨®åˆ¥ã”ã¨ã« Slack ã«è¡¨ç¤ºã™ã‚‹è©³ç´°æƒ…å ±ã‚’æ§‹ç¯‰
  let details = '';
  let warn = '';
  if (toolName === 'Bash') {
    const cmd = toolInput.command || '';
    // å±é™ºãªã‚³ãƒãƒ³ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡ºï¼ˆrm -r, sudo, git push --force ç­‰ï¼‰
    const dangerPatterns = [
      /rm\s+(-[^\s]*r|--recursive)/, /sudo\s/, /chmod\s+777/,
      /git\s+(push\s+(-f|--force)|reset\s+--hard|clean\s+-f)/,
      /DROP\s+(TABLE|DATABASE)/i, /curl.*\|\s*(ba)?sh/,
      /mkfs\./, /dd\s+if=/
    ];
    if (dangerPatterns.some(p => p.test(cmd))) warn = ':rotating_light: ';
    details = `${warn}*Command:*\n\`\`\`${truncate(cmd, 2500)}\`\`\``;
    if (toolInput.description) {
      details += `\n*Description:* ${truncate(toolInput.description, 200)}`;
    }
  } else if (toolName === 'Write') {
    // ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿: ãƒ‘ã‚¹ã€ã‚µã‚¤ã‚ºã€å…ˆé ­10è¡Œã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
    const content = toolInput.content || '';
    const lines = content.split('\n');
    details = `*File:* \`${toolInput.file_path || ''}\`\n*Size:* ${content.length} chars, ${lines.length} lines`;
    const preview = lines.slice(0, 10).join('\n');
    if (preview) {
      details += `\n*Preview:*\n\`\`\`${truncate(preview, 500)}\`\`\``;
    }
    if (lines.length > 10) details += `\n_...and ${lines.length - 10} more lines_`;
  } else if (toolName === 'Edit') {
    // ãƒ•ã‚¡ã‚¤ãƒ«ç·¨é›†: ãƒ‘ã‚¹ã€ç½®æ›å‰/å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤º
    details = `*File:* \`${toolInput.file_path || ''}\``;
    if (toolInput.old_string) {
      details += `\n*Replace:*\n\`\`\`${truncate(toolInput.old_string, 800)}\`\`\``;
    }
    if (toolInput.new_string) {
      details += `\n*With:*\n\`\`\`${truncate(toolInput.new_string, 800)}\`\`\``;
    }
    if (toolInput.replace_all) details += `\n:warning: *replace_all: true*`;
  } else {
    // ãã®ä»–ã®ãƒ„ãƒ¼ãƒ«: JSON ã‚’ãã®ã¾ã¾è¡¨ç¤º
    const inputStr = JSON.stringify(toolInput, null, 2);
    details = `\`\`\`${truncate(inputStr, 2500)}\`\`\``;
  }

  // AI ã‚µãƒãƒªãƒ¼ï¼ˆä»»æ„: anthropic_api_key ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ï¼‰
  const summary = await generateSummary(config, toolName, toolInput, input.transcript_path);

  // Slack Block Kit ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ§‹ç¯‰
  const contextElements = [
    { type: 'mrkdwn', text: `Session: \`${sessionId.slice(0, 8)}\`` },
    ...getProjectContext().map(text => ({ type: 'mrkdwn', text }))
  ];

  const blocks = [
    {
      type: 'header',
      text: { type: 'plain_text', text: truncate(`${warn}Permission: ${toolName}`, 150), emoji: true }
    },
    ...(summary ? [{
      type: 'section',
      text: { type: 'mrkdwn', text: `ğŸ’¡ ${summary}` }
    }] : []),
    {
      type: 'section',
      text: { type: 'mrkdwn', text: truncate(details, 3000) }
    },
    {
      type: 'context',
      elements: contextElements
    },
    { type: 'divider' },
    {
      type: 'section',
      text: { type: 'mrkdwn', text: 'âœ… React to approve, âŒ to deny  â€”  or reply: *approve* / *deny*' }
    }
  ];

  try {
    // Slack ã«ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æŠ•ç¨¿
    const result = await postMessage(
      config.slack_bot_token, config.channel_id,
      `Permission Request: ${toolName}`, blocks
    );

    // æ‰¿èª/æ‹’å¦ã®å¿œç­”ã‚’ãƒãƒ¼ãƒªãƒ³ã‚°ã§å¾…ã¤
    const approval = await pollForApproval(
      config.slack_bot_token, config.channel_id,
      result.ts, (config.timeout || 300) * 1000
    );

    if (!approval) {
      // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ä½•ã‚‚å‡ºåŠ›ã›ãšã«çµ‚äº†ã—ã€ãƒ­ãƒ¼ã‚«ãƒ«ã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      debugLog('hookPermissionRequest: timed out, falling back to local prompt');
      process.exit(0);
    }

    const decision = approval.decision;
    debugLog(`hookPermissionRequest: decision=${decision} source=${approval.source} detail="${approval.detail}"`);

    // Claude Code ã®ãƒ•ãƒƒã‚¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«å¾“ã„ã€æ‰¿èª/æ‹’å¦ã‚’ JSON ã§æ¨™æº–å‡ºåŠ›ã«è¿”ã™
    const output = JSON.stringify({
      hookSpecificOutput: {
        hookEventName: 'PermissionRequest',
        decision: { behavior: decision }
      }
    });
    debugLog(`hookPermissionRequest: output=${output}`);
    console.log(output);
  } catch (e) {
    debugLog(`hookPermissionRequest: error: ${e.message}`);
  } finally {
    releaseLock('permission');
  }
}

/**
 * AskUserQuestion ãƒ•ãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ã€‚
 * Claude Code ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è³ªå•ã™ã‚‹éš›ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚
 *
 * å‡¦ç†ãƒ•ãƒ­ãƒ¼:
 *   1. è³ªå•å†…å®¹ã‚’ Slack ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã—ã¦æŠ•ç¨¿ï¼ˆé¸æŠè‚¢ãŒã‚ã‚‹å ´åˆã¯ç•ªå·ä»˜ããƒªã‚¹ãƒˆï¼‰
 *   2. ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡ã‚’ãƒãƒ¼ãƒªãƒ³ã‚°ã—ã¦å›ç­”ã‚’å¾…ã¤
 *   3. ç•ªå·ã§å›ç­”ã•ã‚ŒãŸå ´åˆã¯å¯¾å¿œã™ã‚‹é¸æŠè‚¢ã®ãƒ©ãƒ™ãƒ«ã«å¤‰æ›
 *   4. PreToolUse ã® deny ã¨ã—ã¦å‡ºåŠ›ã—ã€additionalContext ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å›ç­”ã‚’è¼‰ã›ã‚‹
 *      ï¼ˆã“ã‚Œã«ã‚ˆã‚Š Claude ã¯åŒã˜è³ªå•ã‚’å†åº¦è¡¨ç¤ºã›ãšã€Slack ã®å›ç­”ã‚’åˆ©ç”¨ã—ã¦ç¶šè¡Œã™ã‚‹ï¼‰
 */
async function hookAskUserQuestion() {
  debugLog('hookAskUserQuestion: start');
  if (!isEnabled()) { debugLog('hookAskUserQuestion: disabled, exit'); process.exit(0); }

  const config = loadConfig();
  if (!config?.slack_bot_token || !config?.channel_id) { debugLog('hookAskUserQuestion: no config, exit'); process.exit(0); }

  let input;
  try {
    const raw = await readStdin();
    debugLog(`hookAskUserQuestion: stdin length=${raw.length}`);
    input = JSON.parse(raw);
  } catch (e) {
    debugLog(`hookAskUserQuestion: stdin parse error: ${e.message}`);
    process.exit(0);
  }

  if (!isValidAskUserQuestion(input)) {
    debugLog(`hookAskUserQuestion: REJECTED invalid input: ${JSON.stringify(input).slice(0, 200)}`);
    process.exit(0);
  }

  if (!acquireLock('question')) {
    debugLog('hookAskUserQuestion: SKIPPED - another question is already active');
    process.exit(0);
  }

  const toolInput = input.tool_input || {};
  const sessionId = input.session_id || 'unknown';
  const questions = toolInput.questions || [];

  // è³ªå•ãƒ†ã‚­ã‚¹ãƒˆã‚’ Slack mrkdwn å½¢å¼ã§æ§‹ç¯‰ï¼ˆé¸æŠè‚¢ãŒã‚ã‚‹å ´åˆã¯ç•ªå·ä»˜ããƒªã‚¹ãƒˆï¼‰
  let questionText = '';
  for (const q of questions) {
    questionText += `*${q.question}*\n`;
    if (q.options?.length > 0) {
      q.options.forEach((opt, i) => {
        questionText += `  ${i + 1}. *${opt.label}*`;
        if (opt.description) questionText += ` - ${opt.description}`;
        questionText += '\n';
      });
    }
    if (q.multiSelect) {
      questionText += `_(multiple selection allowed)_\n`;
    }
    questionText += '\n';
  }

  const blocks = [
    {
      type: 'header',
      text: { type: 'plain_text', text: 'â“ Claude needs your input', emoji: true }
    },
    {
      type: 'section',
      text: { type: 'mrkdwn', text: truncate(questionText, 3000) }
    },
    {
      type: 'context',
      elements: [{ type: 'mrkdwn', text: `Session: \`${sessionId.slice(0, 8)}\`` }]
    },
    { type: 'divider' },
    {
      type: 'section',
      text: { type: 'mrkdwn', text: 'ğŸ’¬ Reply in thread with a number or text' }
    }
  ];

  try {
    const result = await postMessage(
      config.slack_bot_token, config.channel_id,
      'â“ Claude needs your input', blocks
    );

    // ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡ã‚’ãƒãƒ¼ãƒªãƒ³ã‚°ã—ã¦å›ç­”ã‚’å¾…ã¤
    const reply = await pollForReply(
      config.slack_bot_token, config.channel_id,
      result.ts, (config.timeout || 300) * 1000
    );

    if (!reply) {
      debugLog('hookAskUserQuestion: timed out, falling back to local prompt');
      process.exit(0);
    }

    // ç•ªå·ã§å›ç­”ã•ã‚ŒãŸå ´åˆã€å¯¾å¿œã™ã‚‹é¸æŠè‚¢ã®ãƒ©ãƒ™ãƒ«ã«å¤‰æ›
    let answer = reply.trim();
    const num = parseInt(answer, 10);
    if (!isNaN(num) && questions[0]?.options) {
      const opt = questions[0].options[num - 1];
      if (opt) answer = opt.label;
    }

    debugLog(`hookAskUserQuestion: reply="${reply}" answer="${answer}"`);

    // PreToolUse ã® deny ã¨ã—ã¦å‡ºåŠ›ã—ã€Slack ã®å›ç­”ã‚’ additionalContext ã«è¼‰ã›ã‚‹
    // ã“ã‚Œã«ã‚ˆã‚Š Claude ã¯ AskUserQuestion ãƒ„ãƒ¼ãƒ«ã®å®Ÿè¡Œã‚’ä¸­æ­¢ã—ã€
    // æä¾›ã•ã‚ŒãŸå›ç­”ã‚’ã‚‚ã¨ã«å‡¦ç†ã‚’ç¶šè¡Œã™ã‚‹
    const output = JSON.stringify({
      hookSpecificOutput: {
        hookEventName: 'PreToolUse',
        permissionDecision: 'deny',
        permissionDecisionReason: 'The user has already answered this question via Slack. Their answer is provided in the additional context. Do not ask this question again - proceed with the provided answer.',
        additionalContext: `User answered via Slack: ${answer}`
      }
    });
    debugLog(`hookAskUserQuestion: output=${output}`);
    console.log(output);
  } catch (e) {
    debugLog(`hookAskUserQuestion: error: ${e.message}`);
  } finally {
    releaseLock('question');
  }
}

/**
 * ãƒˆãƒ©ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ Claude ã®æœ€æ–°ã®å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—ã™ã‚‹ã€‚
 * Notification ãƒ•ãƒƒã‚¯ã§ Slack ã« Claude ã®å›ç­”ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã€‚
 * JSONL å½¢å¼ã®ãƒˆãƒ©ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’æœ«å°¾ã‹ã‚‰èµ°æŸ»ã—ã€æœ€åˆã«è¦‹ã¤ã‹ã£ãŸ assistant ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™ã€‚
 */
async function getLastAssistantMessage(transcriptPath) {
  if (!transcriptPath) return null;
  try {
    const content = fs.readFileSync(transcriptPath, 'utf8');
    const lines = content.trim().split('\n');
    // æœ«å°¾ã‹ã‚‰èµ°æŸ»ã—ã¦æœ€æ–°ã® assistant ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¢ã™
    for (let i = lines.length - 1; i >= 0; i--) {
      try {
        const entry = JSON.parse(lines[i]);
        if (entry.message?.role === 'assistant' && Array.isArray(entry.message.content)) {
          const textParts = entry.message.content
            .filter(c => c.type === 'text' && c.text)
            .map(c => c.text);
          if (textParts.length > 0) return textParts.join('\n');
        }
      } catch { /* skip malformed lines */ }
    }
  } catch (e) {
    debugLog(`getLastAssistantMessage: error reading transcript: ${e?.message}`);
  }
  return null;
}

/**
 * Notification ãƒ•ãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ã€‚
 * Claude Code ãŒã‚¢ã‚¤ãƒ‰ãƒ«çŠ¶æ…‹ã«ãªã£ãŸéš›ã‚„å¿œç­”ã‚’å®Œäº†ã—ãŸéš›ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚
 *
 * å‡¦ç†ãƒ•ãƒ­ãƒ¼:
 *   1. ãƒˆãƒ©ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‹ã‚‰ Claude ã®æœ€æ–°ã®å¿œç­”ã‚’å–å¾—
 *   2. å¿œç­”ãŒã‚ã‚Œã°ãã®å†…å®¹ã‚’ã€ãªã‘ã‚Œã°é€šçŸ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ Slack ã«æŠ•ç¨¿
 *   3. ä¸€æ–¹é€šè¡Œã®é€šçŸ¥ã®ãŸã‚ã€æŠ•ç¨¿å¾Œã™ãã«ãƒ—ãƒ­ã‚»ã‚¹ã‚’çµ‚äº†ï¼ˆãƒãƒ¼ãƒªãƒ³ã‚°ãªã—ï¼‰
 *
 * ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆAPI ã‚¨ãƒ©ãƒ¼ç­‰ï¼‰ã¯ Slack ã«é€šçŸ¥ã—ãªã„ã‚ˆã†ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹ã€‚
 */
async function hookNotification() {
  debugLog('hookNotification: start');
  if (!isEnabled()) { debugLog('hookNotification: disabled, exit'); process.exit(0); }

  const config = loadConfig();
  if (!config?.slack_bot_token || !config?.channel_id) { debugLog('hookNotification: no config, exit'); process.exit(0); }

  let input;
  try {
    const raw = await readStdin();
    debugLog(`hookNotification: stdin length=${raw.length}`);
    input = JSON.parse(raw);
  } catch (e) {
    debugLog(`hookNotification: stdin parse error: ${e?.message}`);
    process.exit(0);
  }

  // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é€šçŸ¥å¯¾è±¡å¤–
  if (input.type === 'error' || input.error) {
    debugLog(`hookNotification: REJECTED error object: ${JSON.stringify(input).slice(0, 200)}`);
    process.exit(0);
  }

  const sessionId = input.session_id || 'unknown';
  const message = input.message || 'Claude Code is waiting for input';

  // API ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯é€šçŸ¥å¯¾è±¡å¤–
  if (isErrorMessage(message)) {
    debugLog(`hookNotification: REJECTED error message: ${message.slice(0, 200)}`);
    process.exit(0);
  }

  // ãƒˆãƒ©ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‹ã‚‰ Claude ã®æœ€æ–°ã®å›ç­”ã‚’å–å¾—
  const lastMessage = await getLastAssistantMessage(input.transcript_path);
  debugLog(`hookNotification: lastMessage length=${lastMessage?.length || 0}`);

  const blocks = [
    {
      type: 'header',
      text: { type: 'plain_text', text: 'ğŸ’¬ Claude Code ã‹ã‚‰ã®å›ç­”' }
    }
  ];

  if (lastMessage) {
    blocks.push({
      type: 'section',
      text: { type: 'mrkdwn', text: truncate(lastMessage, 2500) }
    });
  } else {
    blocks.push({
      type: 'section',
      text: { type: 'mrkdwn', text: `â³ ${truncate(message, 2500)}` }
    });
  }

  const projectName = input.cwd ? path.basename(input.cwd) : '';
  const contextParts = [`Session: \`${sessionId.slice(0, 8)}\``];
  if (projectName) contextParts.push(`Project: \`${projectName}\``);

  blocks.push(
    { type: 'divider' },
    {
      type: 'context',
      elements: [
        { type: 'mrkdwn', text: contextParts.join('  |  ') },
        { type: 'mrkdwn', text: 'â„¹ï¸ ã“ã®å›ç­”ã¸ã®è¿”ä¿¡ã¯ Slack ã‹ã‚‰ã¯ã§ãã¾ã›ã‚“ã€‚ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚' }
      ]
    }
  );

  debugLog(`hookNotification: posting message with ${lastMessage ? 'assistant response' : 'fallback'}`);

  try {
    await postMessage(
      config.slack_bot_token, config.channel_id,
      lastMessage ? 'ğŸ’¬ Claude Code ã‹ã‚‰ã®å›ç­”ãŒã‚ã‚Šã¾ã™' : `â³ ${message}`,
      blocks
    );
    debugLog('hookNotification: posted successfully');
  } catch (e) {
    debugLog(`hookNotification: error: ${e?.message}`);
  }

  process.exit(0);
}

// --- CLI ã‚³ãƒãƒ³ãƒ‰ ---

/** Slack é€£æºã‚’æœ‰åŠ¹ã«ã™ã‚‹ã€‚--local ã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ­ãƒ¼ã‚«ãƒ«ã€ãªã—ã§ã‚°ãƒ­ãƒ¼ãƒãƒ«ã€‚ */
async function cmdEnable(args) {
  const isLocal = args.includes('--local');
  if (isLocal) {
    const config = loadConfig() || {};
    saveLocalConfig({ ...config, enabled: true });
    console.log('claude-slack: ENABLED (project-local)');
  } else {
    saveState({ enabled: true });
    console.log('claude-slack: ENABLED (global)');
  }
}

/** Slack é€£æºã‚’ç„¡åŠ¹ã«ã™ã‚‹ã€‚--local ã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ­ãƒ¼ã‚«ãƒ«ã€ãªã—ã§ã‚°ãƒ­ãƒ¼ãƒãƒ«ã€‚ */
async function cmdDisable(args) {
  const isLocal = args.includes('--local');
  if (isLocal) {
    const config = loadConfig() || {};
    saveLocalConfig({ ...config, enabled: false });
    console.log('claude-slack: DISABLED (project-local)');
  } else {
    saveState({ enabled: false });
    console.log('claude-slack: DISABLED (global)');
  }
}

/**
 * Slack ãƒˆãƒ¼ã‚¯ãƒ³ãƒ»ãƒãƒ£ãƒ³ãƒãƒ« IDãƒ»ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç­‰ã‚’è¨­å®šã™ã‚‹ã€‚
 * --local ã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ­ãƒ¼ã‚«ãƒ«ã€ãªã—ã§ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã«ä¿å­˜ã€‚
 * å¼•æ•°ãªã—ã®å ´åˆã¯ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤ºã€‚
 */
async function cmdConfig(args) {
  const isLocal = args.includes('--local');
  const filteredArgs = args.filter(a => a !== '--local');
  const config = {};

  for (let i = 0; i < filteredArgs.length; i++) {
    if (filteredArgs[i] === '--token' && filteredArgs[i + 1]) {
      config.slack_bot_token = filteredArgs[++i];
    } else if (filteredArgs[i] === '--channel' && filteredArgs[i + 1]) {
      config.channel_id = filteredArgs[++i];
    } else if (filteredArgs[i] === '--timeout' && filteredArgs[i + 1]) {
      config.timeout = parseInt(filteredArgs[++i], 10);
    } else if (filteredArgs[i] === '--anthropic-key' && filteredArgs[i + 1]) {
      config.anthropic_api_key = filteredArgs[++i];
    }
  }

  if (!config.slack_bot_token && !config.channel_id && !config.anthropic_api_key) {
    console.log('Usage: claude-slack config [--local] --token <xoxb-...> --channel <C...> [options]');
    console.log('');
    console.log('Required:');
    console.log('  --token          Slack Bot User OAuth Token (starts with xoxb-)');
    console.log('  --channel        Slack Channel ID (starts with C)');
    console.log('');
    console.log('Optional:');
    console.log('  --timeout        Reply timeout in seconds (default: 300)');
    console.log('  --anthropic-key  Anthropic API Key for AI summary (sk-ant-...)');
    console.log('  --local          Save to project-local .claude/claude-slack.local.md');
    console.log('');
    console.log('Environment variables (highest priority):');
    console.log('  CLAUDE_SLACK_TOKEN    Slack Bot Token');
    console.log('  CLAUDE_SLACK_CHANNEL  Channel ID');
    console.log('  CLAUDE_SLACK_TIMEOUT  Timeout in seconds');
    console.log('  CLAUDE_SLACK_ENABLED  Enable/disable (true/false)');
    console.log('  ANTHROPIC_API_KEY     Anthropic API Key for AI summary');
    return;
  }

  if (isLocal) {
    saveLocalConfig(config);
    console.log('Configuration saved to .claude/claude-slack.local.md');
  } else {
    // Merge with existing global config
    const existing = loadConfig() || {};
    const merged = { ...existing, ...config };
    delete merged._source;
    delete merged._localEnabled;
    delete merged._localPath;
    saveConfig(merged);
    console.log('Configuration saved to ~/.claude-slack/config.json');
  }
  console.log(`  Channel:  ${config.channel_id || '(not set)'}`);
  console.log(`  Token:    ${config.slack_bot_token ? config.slack_bot_token.slice(0, 12) + '****' : '(not set)'}`);
  console.log(`  Timeout:  ${config.timeout || 300}s`);
}

/** Slack æ¥ç¶šãƒ†ã‚¹ãƒˆã€‚è¨­å®šæ¸ˆã¿ã®ãƒãƒ£ãƒ³ãƒãƒ«ã«ãƒ†ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿ã—ã¦å‹•ä½œç¢ºèªã™ã‚‹ã€‚ */
async function cmdTest() {
  const config = loadConfig();
  if (!config?.slack_bot_token || !config?.channel_id) {
    console.error('Error: Configuration not found.');
    console.error('Run: claude-slack config --token <xoxb-...> --channel <C...>');
    process.exit(1);
  }

  console.log('Testing Slack connection...');
  try {
    const result = await postMessage(
      config.slack_bot_token, config.channel_id,
      'ğŸ§ª claude-slack connection test',
      [{
        type: 'section',
        text: { type: 'mrkdwn', text: 'ğŸ§ª *claude-slack connection test*\nThis message confirms the integration is working.' }
      }]
    );
    console.log(`SUCCESS: Test message posted (ts: ${result.ts})`);
    console.log(`Channel: ${config.channel_id}`);
  } catch (e) {
    console.error(`FAILED: ${e.message}`);
    process.exit(1);
  }
}

/** ç¾åœ¨ã®è¨­å®šçŠ¶æ…‹ã‚’è¡¨ç¤ºã™ã‚‹ã€‚å„è¨­å®šå€¤ã®å‡ºæ‰€ï¼ˆglobal/local/envï¼‰ã‚‚è¡¨ç¤ºã€‚ */
async function cmdStatus() {
  const enabled = isEnabled();
  const config = loadConfig();

  // æœ‰åŠ¹/ç„¡åŠ¹ã®çŠ¶æ…‹ãŒã©ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§æ±ºã¾ã£ã¦ã„ã‚‹ã‹ã‚’åˆ¤å®š
  let enabledSource = 'global';
  if (process.env.CLAUDE_SLACK_ENABLED !== undefined) enabledSource = 'env';
  else if (config?._localEnabled !== undefined) enabledSource = 'local';

  console.log('=== claude-slack status ===');
  console.log(`State:    ${enabled ? 'ENABLED' : 'DISABLED'} (source: ${enabledSource})`);
  if (config) {
    const src = config._source || {};
    console.log(`Channel:  ${config.channel_id || '(not set)'}${src.channel_id ? ` (source: ${src.channel_id})` : ''}`);
    console.log(`Token:    ${config.slack_bot_token ? config.slack_bot_token.slice(0, 12) + '****' : '(not set)'}${src.slack_bot_token ? ` (source: ${src.slack_bot_token})` : ''}`);
    console.log(`Timeout:  ${config.timeout || 300}s${src.timeout ? ` (source: ${src.timeout})` : ''}`);
    console.log(`AI:       ${config.anthropic_api_key ? 'ENABLED' : 'OFF'}${src.anthropic_api_key ? ` (source: ${src.anthropic_api_key})` : ''}`);
    if (config._localPath) {
      console.log(`Local:    ${config._localPath}`);
    }
  } else {
    console.log('Config:   Not configured');
    console.log('  Run: claude-slack config --token <xoxb-...> --channel <C...>');
  }
}

// --- ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ ---

/**
 * CLI ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã€‚
 * ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã«å¿œã˜ã¦ãƒ•ãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ã¾ãŸã¯ CLI ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
 *
 * ãƒ•ãƒƒã‚¯:
 *   claude-slack hook permission-request  â€” PermissionRequest ãƒ•ãƒƒã‚¯
 *   claude-slack hook ask-user-question   â€” AskUserQuestion ãƒ•ãƒƒã‚¯
 *   claude-slack hook notification        â€” Notification ãƒ•ãƒƒã‚¯
 *
 * CLI ã‚³ãƒãƒ³ãƒ‰:
 *   claude-slack enable [--local]   â€” æœ‰åŠ¹åŒ–
 *   claude-slack disable [--local]  â€” ç„¡åŠ¹åŒ–
 *   claude-slack config [--local]   â€” è¨­å®š
 *   claude-slack test               â€” æ¥ç¶šãƒ†ã‚¹ãƒˆ
 *   claude-slack status             â€” çŠ¶æ…‹è¡¨ç¤º
 */
async function main() {
  const args = process.argv.slice(2);
  const command = args[0];

  try {
    switch (command) {
      case 'hook':
        // ãƒ•ãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©: Claude Code ã®ãƒ•ãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹
        switch (args[1]) {
          case 'permission-request': await hookPermissionRequest(); break;
          case 'ask-user-question':  await hookAskUserQuestion(); break;
          case 'notification':       await hookNotification(); break;
          default:
            console.error(`Unknown hook: ${args[1]}`);
            process.exit(1);
        }
        break;
      case 'enable':    await cmdEnable(args.slice(1)); break;
      case 'disable':   await cmdDisable(args.slice(1)); break;
      case 'config':    await cmdConfig(args.slice(1)); break;
      case 'test':      await cmdTest(); break;
      case 'status':    await cmdStatus(); break;
      default:
        console.log('claude-slack - Route Claude Code approvals and questions to Slack');
        console.log('');
        console.log('Usage: claude-slack <command>');
        console.log('');
        console.log('Configuration:');
        console.log('  config           Set Slack token, channel, and timeout (global)');
        console.log('  config --local   Save config to current project');
        console.log('  test             Test Slack connection');
        console.log('');
        console.log('Control:');
        console.log('  enable           Enable Slack routing (global)');
        console.log('  enable --local   Enable for current project only');
        console.log('  disable          Disable Slack routing (global)');
        console.log('  disable --local  Disable for current project only');
        console.log('  status           Show current configuration and sources');
        break;
    }
  } catch (e) {
    console.error(`Error: ${e.message}`);
    process.exit(1);
  }
}

main();
